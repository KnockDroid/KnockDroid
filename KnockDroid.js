class KnockDroid{
	constructor(){
		let self = this;

        /**
         * Config
         * contains basic configuration for loading path files
         */
        self.config = {
            /**
             * 1. host
             * the host where KnockDroid will look for ViewModel file.
             * be default the app will look for the files in the app 
             * root folder ( where the index.html file is located ).
             * 2. defaultRoute
             * the default path to load
             * default value is "home"
             * 3. idCounter
             * Counter for generating unique IDs for every UI element
             * that is created.
             */
            host : "",
            routes : [],
            idCounter : 0

        }

        /**
         * Routes
         * will contain all routes and their sub routes
         */
        self.routes = {
            default : "",
            kids : {
                /**
                 * Format
                    Path : {
                        file : ".js file absolute path",
                        id : "custom_or_auto",
                        kids : {
                            Path : {
                                id : "custom_or_auto",
                                kids : {
                                    .......same format
                                }
                            }
                        }
                    }
                 */
            },
            tree : [ 
                /**
                rootPath, subPath, ...subPathN
                */
            ]
        }

        /**
         * Globals
         * It contains data of all routes with it's ID
         */
        self.data = {
            /**
             * Format
                route_ID : {

                    * Container for storing UI elements for this route with
                    * an ID supplied received from the ViewModel or auto 
                    * generated by the app
                    ui : {
                        ui_ID1 : MUI_Element,
                        ui_ID2 : MUI_Element
                    },

                    * Main layout file of the route that is to be attached
                    * to the app object ( if the route is in top level ) 
                    * or to be attached to any parent layout.
                    view : LayoutObject

                    * Model for the View received from js file
                    model : {},
                    
                    * A layout to display views of sub routes of this route ( if any )
                    kidsView : LayoutObject

                    * It will store all sub routes data of this route ( If any ) in 
                    * the same format as described above.
                    kids : {
                        sub_route_ID : {
                            * Same as above
                            ui, view, model, kidsView, kids : {
                                * Same as above
                            }
                        }
                    }
                }
             */
        }

        self.global = {
            regex : {
                /**
                 * Regex to find observable keys inside a text binding
                 * It's not efficient and I wont recommend to use text 
                 * bindings, instead use computed bindings.
                 */
                obs : /<(.*?)>/g
            }
        }
	}

    configure( routes, host ){
        let self = this;
        self.config.host = host ? host : "";
        self.config.routes = routes ? routes : [];
        return new Promise(
            (Resolve, Reject)=>{
                switch( typeof routes ){
                    case "string":
                        /**
                         * Get router config from remote host
                         */
                        require( 
                            [self.config.host + self.config.routes + ".js"],
                            /** ra ~ routesArray */
                            (ra)=>{
                                /**
                                 * Empty the routes object
                                 * insert new routes object
                                 */
                                self.routes.kids = {};
                                self.parseRoutes( ra, self.routes );
                                Resolve();
                            }
                        );
                    break;
                }
            }
        );
    }

    parseRoutes( ra, parent ){
        let self = this
        ra.forEach(
            (r)=>{
                parent.kids[r.path] = {
                    file : self.config.host + (r.file ? r.file : r.path) + ".js",
                    kids : {}
                };
                if( r.default )
                    parent.default = r.path;
            }
        );
    }

    start(){
        let self = this;
        window.onhashchange = function(){
            self.parse();
        }
        self.navigate( self.routes.default );
    }

    navigate( path ){
        let self = this;
        path = path ? path : self.routes.default;
        window.location = "#/" + path
    }

    parse(){
        let self = this;
        let hash = window.location.hash.replace("#/", "");
        let i = 0;
        let hashArray = hash.split("/");
        self.load( hashArray, 0, self.routes.kids, self.data );
    }

    load( hashArray, pos, routes, data, parent ){
        let self = this,
            hash = hashArray[pos],
            tree = self.routes.tree;
        if( tree[pos]==hash ){
            let id = routes[hash].id;
            routes = routes[hash].kids;
            data = data[id].kids;
            parent = data[id].view.ui;
            self.load( hashArray, pos+1, routes, data, parent );
        }else{
            if( !routes[hash] ){
                self.error(404, "Route '" + hash + "' not found");
                self.routes.tree.splice( pos );
            }else{
                if( tree[pos] ){
                    let activeID = routes[tree[pos]].id;
                    data[activeID].view.ui.Animate( "FadeOut" );
                }
                if( !routes[hash].id ){
                    require( 
                        [ routes[hash].file ],
                        vm=>{
                            routes[hash].id = vm.id ? vm.id : self.getID();
                            if( vm.routes) self.parseRoutes( vm.routes, routes[hash] );
                            data[routes[hash].id] = {
                                ui : {},
                                view : {},
                                model : {},
                                kidsView : {},
                                default : "",
                                kids : {}
                            }
                            self.render( data[routes[hash].id], vm, parent );
                            self.routes.tree.splice( pos );
                            self.routes.tree.push( hash );
                        }
                    );
                }else{
                    let currentID = routes[hash].id;
                    data[currentID].view.ui.Animate( "FadeIn" );
                    self.routes.tree.splice( pos );
                    self.routes.tree.push( hash );
                }
                //data[tree[pos]].view.Animate( "FadeOut" );
                //data[id].view.Animate( "FadeIn" );
                //self.routes.tree.splice( pos );
                //self.routes.tree.push( hash );
            }
        }
    }

    render( data, vm, parent ){
        let self = this;
        data.model = vm.Model;
        let layout = vm.View.Layout;
        data.view = new kdUI( "Layout", layout, {} );
        data.view.ui.SetVisibility( "Hide" );
        if( parent )
            parent.AddChild( data.view.ui );
        else{
            app.AddLayout( data.view.ui );
        }
        self.renderKids( vm.View.Layout.kids, data.model, data.view.ui, data.kids, data );
        data.view.ui.Animate( "FadeIn" );
    }
    
    renderKids( kids, model, parent, kidsContainer, parentObject ){
        let self = this;
        let tmp;
        let id;
        for( let k in kids ){
            if( k=="kidsView" ){
                parentObject.kidsView = new kdUI( "Layout", kids[k], {} );
                parent.AddChild( parentObject.kidsView.ui );
            }else{
                tmp = kids[k];
                id = self.getID();
                kidsContainer[id] = new kdUI( k, kids[k], model );
                parent.AddChild( kidsContainer[id].ui );
                if( tmp.kids )
                    self.renderKids( tmp.kids, model, kidsContainer[id], kidsContainer, parentObject );
            }
        }
    }

    error( code, msg ){
        app.ShowPopup( code + " Error : " + msg );
    }

    getID(){
        let self = this;
        return "auto_generated_" + (self.config.idCounter++);
    }

    parseText( ui, model ){
        let self = this;
        let text = ui.text;
        ui.obs.forEach(o=>{
            text = text.split( '<'+o+'>' ).join( model[o]() );
        });
        return text;
    }

    getTextMethod( uiKey ){
        switch( uiKey ){
            case "AppBar":
                return {
                    set : "SetTitleText"
                };
            break;
            default:
                return {
                    set : "SetText",
                    get : "GetText"
                }
            break;
        }
    }
}


class kdUI{
    constructor(uiKey, uiData, model){
        let self = this;
        self.ui = MUI["Create" + uiKey]( ...uiData.init );
        if( uiData.methods ){
            for( let m in uiData.methods ){
                if( typeof uiData.methods[m] =="object" )
                    self.ui[m]( ...uiData.methods[m] );
                else
                    self.ui[m]( uiData.methods[m] );
            }
        }
        if( uiData.bind ){
            let textMethod = self.getTextMethod(uiKey);
            self.bind = {}
            for( let b in uiData.bind ){
                switch( b ){
                    case "text":
                        self.bind.text = {
                            value : uiData.bind.text,
                            obs : []
                        };
                        let obs = self.ui.text.matchAll( self.regex.obs );
                        for( let obsName of obs ){
                            self.bind.text.obs.push( obsName[1] );
                            if( model[obsName[1]] ){
                                model[obsName[1]].subscribe( newVal=>{
                                    self.ui[textMethod.set]( self.parseText( self.bind.text, model ) );
                                } );
                            }
                        }
                        self.ui[textMethod.set]( self.parseText( self.bind.text, model ) );
                    break;
                    case "computed":
                        self.bind.computed = uiData.bind.computed;
                        model[self.bind.computed].subscribe( function( newVal ){
                            self.ui[textMethod.set]( newVal );
                        } );
                        self.ui[textMethod.set]( model[self.bind.computed]() );
                    break;
                    case "value":
                        let val = uiData.bind.value;
                        model[val.obs].subscribe( newVal=>{
                            if(self.ui[textMethod.get]()!=model[val.obs]())
                            self.ui[textMethod.set]( model[val.obs]() );
                        } );
                        self.ui[textMethod.set]( model[val.obs]() );
                        //Two way
                        self.ui[val.ev]( ()=>{
                            model[val.obs](self.ui[textMethod.get]());
                        } );
                    break;
                    case "event":
                        for( let e in uiData.bind.event ){
                            if( typeof uiData.bind.event[e]=="string" )
                                self.ui[e]( model[uiData.bind.event[e]] );
                            else if( typeof uiData.bind.event[e]=="function" )
                                self.ui[e]( uiData.bind.event[e] );
                        }
                    break;
                    case "href":
                        let ev = uiData.bind.href.ev;
                        let path = uiData.bind.href.path;
                        self.ui.path = path
                        self.ui[ev]( function(){
                            kd.navigate( this.path );
                        } );
                    break;
                }
            }
        }
    }

    parseText( ui, model ){
        let text = ui.value;
        ui.obs.forEach(o=>{
            text = text.split( '<'+o+'>' ).join( model[o]() );
        });
        return text;
    }

    getTextMethod( uiKey ){
        switch( uiKey ){
            case "AppBar":
                return {
                    set : "SetTitleText"
                };
            break;
            default:
                return {
                    set : "SetText",
                    get : "GetText"
                }
            break;
        }
    }
}