class KnockDroid{
	constructor( home, host ){
		let self = this;

        /**
         * Config
         * contains basic configuration for loading path files
         */
        self.config = {
            /**
             * 1. host
             * the host where KnockDroid will look for ViewModel file.
             * be default the app will look for the files in the app 
             * root folder ( where the index.html file is located ).
             * 2. defaultRoute
             * the default path to load
             * default value is "home"
             * 3. idCounter
             * Counter for generating unique IDs for every UI element
             * that is created.
             */
            host : host ? host : "",
            defaultRoute : home ? home : "home",
            idCounter : 0

        }

        /**
         * Modules
         * It will store top level paths and it's data
         * format
         * { 
         *  path1 : {},
         *  path2 : {}
         * }
         */
        self.modules = {
            /**
             * Paths : {}
             * It will store data of a page which includes
                * 1. config {}
                * the ViewModel object recived from the js path file using require()
                * 2. view   Layout
                * the main view layout that is to be attached to the app
                * 3. model  {}
                * the model separated from config.Model
                * 4. routes {path : {}}
                * object containing sub paths with its data 
                * data is in the same format as self.modules
             */
        }

        /**
         * Globals
         * It contains data that a Model may use to communicate with 
         * UI objects based on IDs
         */
        self.global = {
            ui : {
                /**
                 * id : {UI Element}
                 * Every UI element that is created are attached in here with
                 * a random ID generated by the app or a custom ID from the
                 * ViewModel object.
                 * For custom IDs, make it unique among all the views that your 
                 * app may have
                 */
            },
            model : {
                /**
                 * id : {Models of all views}
                 * Everytime a new page is created, the model for the view are
                 * attached in here with a random ID generated by the app or a
                 * custom ID from the ViewModel object.
                 * You can access model of any other page by setting a custom id
                 * of the model and referring it as 
                    * kd.global.model[modleCustomID]
                 * For custom IDs, make it unique among all the models that your
                 * app may have.
                 */
            }
        }

        /**
         * active
         * will contain the current router data
             * 1. path          "window.location.hash"
             * the hash as a whole
             * 2. pathTree      {level1Path : { level2Path : { level3Path : {} }}}
             * the hash divided into paths and sub paths 
         */
        self.active = {
            path : {},
            pathTree : {}
        }


        self.host = host ? host : "";
        self.home = home ? home : "home";
        self.counter = 0;
        self.root = {
            vm : {},
            view : {},
            model : {},
            layout : {},
            kids : {},
            //Route properties
            routes : {},
            allRoutes : {},
            defaultRoute : "",
            currentRoute : {
                path : "",
                lay : false,
                kids : {},
                view : {},
                model : {}
            },
            routerView : false
        }
        self.regex = {
            //obs : /<([^}]+)>/g,
            obs : /<(.*?)>/g,
            exp : /\{([^}]+)\}/g
        }
        self.data = {}

        //Load Home Module
		require( [self.host + self.home + ".js"], vm=>{
            self.root.vm = vm;
            self.renderRoot( self.root.vm );
        } );
	}

    init = function(){
        window.onhashchange = function(){
            self.load();
        }
    }

    parse(){
        /**
         * This method will get the hash from the URL and then
         * if there's no hash in the URL then it will redirect
         * the user to the default hash.
         * else it will compare the hash with the active.pathTree to
         * check whether any starting segment matches with the root 
         * paths of active.pathTree.
            * if the hash matches a root path as a whole
                * it will update the self.active.pathTree
            * if only a part of the starting segment of the hash matches
                * it will set the root level of the pathTree to the
                * matched segment and it's subtree will have the 
                * remaining segment of the hash.
                * Now, it will check if the root level path is already 
                * loaded into the app and is visible.
                * The remaining segment will also be parsed once the parent
                * segment gets loaded.
         */
        let hash = window.location.hash.replace("#/", "");
        // root level modules should be set in constructor
        //..Continue From Here
    }

    load(  ){

    }

    renderRoot( vm ){
        let self = this;
        self.root.view = vm.View;
        self.root.model = vm.Model;
        self.root.layout = self.getUi( "Layout", vm.View.Layout, vm.Model );
        self.root.kids = {}
        app.AddLayout( self.root.layout );
        self.renderKids( vm.View["Layout"].kids, vm.Model, self.root.layout, self.root.kids );
        self.root.routes = self.root.vm.Routes ? self.root.vm.Routes : [];
        self.routerInit();
    }

    renderKids( kids, model, parent, kidsContainer ){
        let self = this;
        let tmp;
        let id;
        for( let k in kids ){
            if( k=="RouterView" ){
                if( !self.root.routerView ){
                    self.root.routerView = self.getUi( "Layout", kids[k], {} );
                    parent.AddChild( self.root.routerView );
                }
            }else{
                tmp = kids[k];
                self.counter = self.counter+1;
                id = "kid_id_" + self.counter;
                kidsContainer[id] = self.getUi( k, kids[k], model );
                parent.AddChild( kidsContainer[id] );
                if( tmp.kids )
                    self.renderKids( tmp.kids, model, kidsContainer[id], kidsContainer );
            }
        }
    }
    
    getUi( uiKey, uiData, model ){
        let self = this;
        let ui = null;
        ui = MUI["Create" + uiKey]( ...uiData.init );
        if( uiData.methods ){
            for( let m in uiData.methods ){
                if( typeof uiData.methods[m] =="object" )
                    ui[m]( ...uiData.methods[m] );
                else
                    ui[m]( uiData.methods[m] );
            }
        }
        if( uiData.bind ){
            let textMethod = self.getTextMethod(uiKey);
            for( let b in uiData.bind ){
                switch( b ){
                    case "text":
                        ui.text = uiData.bind.text;
                        ui.obs = [];
                        let obs = ui.text.matchAll( self.regex.obs );
                        for( let obsName of obs ){
                            ui.obs.push( obsName[1] );
                            if( model[obsName[1]] ){
                                model[obsName[1]].subscribe( newVal=>{
                                    ui[textMethod.set]( self.parseText( ui, model ) );
                                } );
                            }
                        }
                        ui[textMethod.set]( self.parseText( ui, model ) );
                    break;
                    case "computed":
                        let computed = uiData.bind.computed;
                        model[computed].subscribe( function( newVal ){
                            ui[textMethod.set]( newVal );
                        } );
                        ui[textMethod.set]( model[computed]() );
                    break;
                    case "value":
                        let val = uiData.bind.value;
                        model[val.obs].subscribe( newVal=>{
                            if(ui[textMethod.get]()!=model[val.obs]())
                                ui[textMethod.set]( model[val.obs]() );
                        } );
                        ui[textMethod.set]( model[val.obs]() );
                        //Two way
                        ui[val.ev]( ()=>{
                            model[val.obs](ui[textMethod.get]());
                        } );
                    break;
                    case "event":
                        for( let e in uiData.bind.event ){
                            ui[e]( model[uiData.bind.event[e]] );
                        }
                    break;
                    case "href":
                        let ev = uiData.bind.href.ev;
                        let path = uiData.bind.href.path;
                        ui[ev]( function(){
                            kd.navigate( path );
                        } );
                    break;
                }
            }
        }
        return ui;
    }

    parseText( ui, model ){
        let self = this;
        let text = ui.text;
        ui.obs.forEach(o=>{
            text = text.split( '<'+o+'>' ).join( model[o]() );
        });
        return text;
    }

    getTextMethod( uiKey ){
        switch( uiKey ){
            case "AppBar":
                return {
                    set : "SetTitleText"
                };
            break;
            default:
                return {
                    set : "SetText",
                    get : "GetText"
                }
            break;
        }
    }

    routerInit(){
        let self = this;
        let routes = self.root.routes;
        self.root.allRoutes = {};
        routes.forEach( r=>{
            self.root.allRoutes[r.path] = r;
            if( r.default ){
                self.root.defaultRoute = r.path;
            }
        } )
        window.onhashchange = function(){
            if( self.root.routerView )
                self.root.routerView.Animate( "FadeOut" );
            self.onNavigate();
        }
        if( self.root.defaultRoute )
            self.navigate( self.root.defaultRoute );
    }

    navigate( path ){
        path = path ? path : self.root.defaultRoute;
        let self = this;
        window.location = "#/" + path
    }

    onNavigate(){
        let self = this;
        let path = window.location.hash.split( "#/" ).join("");
        if( self.root.currentRoute.path!=path ){
            let file = self.root.allRoutes[path].file ? self.root.allRoutes[path].file : self.root.allRoutes[path].path;
            if( file ){
                //Load Home Module
                require( [self.host + file + ".js"], vm=>{
                    self.root.currentRoute.path = path;
                    self.root.currentRoute.view = vm.View;
                    self.root.currentRoute.model = vm.Model;
                    if( self.root.currentRoute.lay && self.root.routerView )
                        self.root.routerView.DestroyChild( self.root.currentRoute.lay );
                    self.root.currentRoute.lay = self.getUi( "Layout", vm.View.Layout, vm.Model );
                    self.root.currentRoute.kids = {}
                    if( self.root.routerView )
                        self.root.routerView.AddChild( self.root.currentRoute.lay );
                    if( vm.View["Layout"].kids ){
                        self.renderKids( vm.View["Layout"].kids, vm.Model, self.root.currentRoute.lay, self.root.currentRoute.kids );
                    }
                    self.root.routerView.Animate( "FadeIn" );
                } );
            }else{
                app.ShowPopup( "Page not found" );
            }
        }
    }
}